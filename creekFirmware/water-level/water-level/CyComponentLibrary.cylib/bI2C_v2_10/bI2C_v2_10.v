/******************************************************************************* 
* File Name: bI2C_v2_10.v 
* Version `$CY_MAJOR_VERSION`.`$CY_MINOR_VERSION`
*  
* Description: 
*  This file provides a base model of the I2C componnent defining and all of the 
*  necessary interconnect.
*
********************************************************************************
*                 Control and Status Register definitions
******************************************************************************** 
* Control Register Definition
*  +=====+------+--------+-----------+--------+----------+--------+---------+--------+
*  | Bit |  7   |   6    |     5     |   4    |    3     |    2   |    1    |   0    |
*  +=====+------+--------+-----------+--------+----------+--------+---------+--------+
*  | Name|unused|stop_gen|restart_gen|  ack   |hw_addr_en|transmit|master_en|slave_en|
*  +=====+------+--------+-----------+--------+----------+--------+---------+--------+
*
*   slave_en	=>	0 = Slave mode is disabled
*                   1 = Slave mode is enabled
*                      
*   master_en	=>	0 = Master mode is disabled
*                   1 = Master mode is enabled
*
*   transmit    =>  0 = Bytes are received from the component
*                   1 = Bytes are transferred from the component
*
*   hw_addr_en	=>	0 = HW Address comparison is enabled 
*                   1 = HW Address comparison is disabled 
*
*   ack       	=>	0 = nack the last received byte
*                   1 = ack the last received byte 
*
*   restart_gen	=>	0 = not generate a Restart condition
*                   1 = generate a Restart condition
*
*   stop_gen	=>	0 = not generate a Stop condition
*                   1 =  generate a Stop condition
*    
*  Status Register Definition
*  +=======+---------+--------+-----------+--------+-------+-----------+--------+-------------+
*  |  Bit  |    7    |   6    |     5     |   4    |   3   |     2     |   1    |     0       |
*  +=======+---------+--------+-----------+--------+-------+-----------+--------+-------------+
*  | Name  |interrupt|lost_arb|stop_status|bus_busy|address|master_mode|   lrb  |byte_complete|
*  +=======+---------+--------+-----------+--------+-------+-----------+--------+-------------+
*
*   byte_complete	=>	0 = no completed transmit/receive 
*                      	1 = eight bits of data have been transmitted/received
*
* 	lrb     		=>	0 = last transmitted byte was ACK'ed by the receiver
*                      	1 = last transmitted byte was NACK'ed by the receiver
*
*   master_mode     =>	0 = stop condition detected, generated by this component
*                      	1 = start condition detected, generated by this component
*
*   address     	=>	0 = 
*                      	1 = the received byte is a slave address
*
*   bus_busy     	=>	0 = when a Stop condition is detected (from any bus master)
*                      	1 = when a Start condition is detected (from any bus master)
*
*  	stop_status     =>  0 = a Stop condition was not detected
*                      	1 = a Stop condition was detected
*   
*	lost_arb     	=>	0 = lost Arbitration event 
*                      	1 = lost Arbitration
******************************************************************************** 
* 					Data Path register definitions
******************************************************************************** 
*  INSTANCE NAME: Shifter 
*  DESCRIPTION: Use for transmit/receive data
*  REGISTER USAGE: 
*   F0 => na 
*   F1 => component API mades dummy load for synchronisation start of transmission 
*   D0 => na  
*   D1 => na 
*   A0 => user writes TX data to A0 and reads RX data from A0 
*   A1 => na  
* 
*********************************************************************************
*  INSTANCE NAME:  ClkGen 
*  DESCRIPTION: Clock Generator
*  REGISTER USAGE: 
*   F0 => na 
*   F1 => na 
*   D0 => contains quantity of samples  
*   D1 => contains half quantity of samples
*   A0 => decremental counter 
*   A1 => na  
*
******************************************************************************** 
* 					I*O Signals:
******************************************************************************** 
*    name              direction       Description
*    clock               input          clock the component is running on 
*    reset               input          reset signal
*    scl_in              input          I2C input clock signal
*    sda_in              input          I2C input data signal 
*    sda_out             output         I2C output data signal
*    scl_out             output         I2C output clock signal
*    irq           	     output         interrupt signal 
* 
********************************************************************************
* Copyright 2008-2010, Cypress Semiconductor Corporation.  All rights reserved.
* You may use this file only in accordance with the license, terms, conditions, 
* disclaimers, and limitations in the end user license agreement accompanying 
* the software package with which this file was provided.
********************************************************************************/

`include "cypress.v"
`ifdef bI2C_v2_10_V_ALREADY_INCLUDED
`else
`define bI2C_v2_10_V_ALREADY_INCLUDED

module bI2C_v2_10
(
    input wire clock,
    input wire reset,
    input wire scl_in,
    input wire sda_in,
    output wire sda_out,
    output wire scl_out,
    output wire irq
);

    localparam I2C_MODE_SLAVE                = 3'h1;
    localparam I2C_MODE_MASTER               = 3'h2;
    localparam I2C_MODE_MULTI_MASTER         = 3'h6;
    localparam I2C_MODE_MULTI_MASTER_SLAVE   = 3'h7;
    
    parameter [2:0] Mode = I2C_MODE_SLAVE;
	
	localparam I2C_DEFAULT_ADDR  		= 8'h04;
	localparam QUANTITY_OF_BITS			= 8'd7; 	
	localparam QUANTITY_OF_SAMPLES		= 8'd15;
	localparam HALF_QUANTITY_OF_SAMPLES	= 8'd8;
    
    localparam I2C_CTRL_UNUSED7         = 3'h7; 
    localparam I2C_CTRL_STOP_GEN        = 3'h6;     /* generate a stop */
    localparam I2C_CTRL_RESTART_GEN     = 3'h5;     /* generate a restart */
    localparam I2C_CTRL_NACK            = 3'h4;     /* 1 = NAK on read, 0 = another byte */
    localparam I2C_CTRL_ANY_ADDRESS     = 3'h3;     /* interrupt on any address */
    localparam I2C_CTRL_TRANSMIT        = 3'h2;     /* 1 = transmit, 0 = receive */
    localparam I2C_CTRL_MASTER_EN       = 3'h1;     /* enable master */
    localparam I2C_CTRL_SLAVE_EN        = 3'h0;     /* enable slave*/

    localparam I2C_STS_LOST_ARB         = 3'h6;     /* transparent */
    localparam I2C_STS_STOP             = 3'h5;     /* sticky */
    localparam I2C_STS_BUS_BUSY         = 3'h4;    	/* transparent */
    localparam I2C_STS_ADDRESS          = 3'h3;     /* transparent */
    localparam I2C_STS_MASTER_MODE      = 3'h2;     /* transparent */
    localparam I2C_STS_LRB              = 3'h1;     /* transparent */
    localparam I2C_STS_BYTE_COMPLETE    = 3'h0;     /* transparent */
    
    /* Master state mashine states*/
	localparam I2C_MASTER_IDLE         = 5'h0;
    localparam I2C_MASTER_PRE_START    = 5'h2;
    localparam I2C_MASTER_START        = 5'h3;
    localparam I2C_MASTER_RESTART      = 5'h4;
    localparam I2C_MASTER_STOP         = 5'h5;
	localparam I2C_MASTER_RX_STALL     = 5'h6;
    localparam I2C_MASTER_TX_STALL     = 5'h7;
    localparam I2C_MASTER_TX_D0        = 5'h8;
    localparam I2C_MASTER_TX_D1        = 5'h9;
    localparam I2C_MASTER_TX_D2        = 5'ha;
    localparam I2C_MASTER_TX_D3        = 5'hb;
    localparam I2C_MASTER_TX_D4        = 5'hc;
    localparam I2C_MASTER_TX_D5        = 5'hd;
    localparam I2C_MASTER_TX_D6        = 5'he;
    localparam I2C_MASTER_TX_D7        = 5'hf;
    localparam I2C_MASTER_RX_D0        = 5'h10;
    localparam I2C_MASTER_RX_D1        = 5'h11;
    localparam I2C_MASTER_RX_D2        = 5'h12;
    localparam I2C_MASTER_RX_D3        = 5'h13;
    localparam I2C_MASTER_RX_D4        = 5'h14;
    localparam I2C_MASTER_RX_D5        = 5'h15;
    localparam I2C_MASTER_RX_D6        = 5'h16;
    localparam I2C_MASTER_RX_D7        = 5'h17;
    localparam I2C_MASTER_RX_ACK       = 5'h18;
    localparam I2C_MASTER_TX_ACK       = 5'h19;

	/* Slave state mashine states*/
    localparam I2C_SLAVE_IDLE      	   = 3'h0;
    localparam I2C_SLAVE_RX_DATA   	   = 3'h1;
    localparam I2C_SLAVE_RX_STALL      = 3'h2;
    localparam I2C_SLAVE_RX_ACK        = 3'h3;
    localparam I2C_SLAVE_TX_DATA       = 3'h4;
    localparam I2C_SLAVE_TX_ACK        = 3'h5;
    localparam I2C_SLAVE_TX_STALL      = 3'h6;

	/* Device Family and Silicon Revision definitions */
    /* PSoC3 ES2 or earlier */
    localparam PSOC3_ES2 = ((`CYDEV_CHIP_MEMBER_USED   == `CYDEV_CHIP_MEMBER_3A) && 
                            (`CYDEV_CHIP_REVISION_USED <= `CYDEV_CHIP_REVISION_3A_ES2));
    /* PSoC5 ES1 or earlier */                        
    localparam PSOC5_ES1 = ((`CYDEV_CHIP_MEMBER_USED   == `CYDEV_CHIP_MEMBER_5A) && 
                            (`CYDEV_CHIP_REVISION_USED <= `CYDEV_CHIP_REVISION_5A_ES1));

    /**************************************************************************/
    /* Common Signals for Master and Slave                                    */
    /**************************************************************************/
    wire op_clk_en;
    wire op_clk;
	wire clk0;
	wire sda_negedge_detect;
    wire sda_posedge_detect;
    wire scl_negedge_detect;
    wire scl_posedge_detect;
    
    wire ctrl_stop_gen;     
    wire ctrl_restart_gen;
    wire ctrl_nack;
    wire ctrl_any_address;
    wire ctrl_transmit;
    wire ctrl_master_en;
    wire ctrl_slave_en;
    
    wire s_load_dummy;
	wire m_load_dummy;
    wire s_shift_en;
	wire m_shift_en;
	wire shift_data_out;
    wire tx_reg_empty;
	wire address_match;
	wire s_reset;
	wire m_reset;
	
    wire [2:0] cs_addr_shifter;
	wire [6:0] status;
    wire [7:0] control;
    
    reg [7:0] control_reg;
	reg sda_in_reg;
    reg scl_in_reg;
	reg sda_in1_reg;
    reg scl_in1_reg;
    reg[4:0] m_state;
	reg[3:0] s_state;
    
    /**************************************************************************/
    /* Signals for Master                                                     */
    /**************************************************************************/
	wire counter_load;
    wire counter_en;
    wire count_eq_zero;

	wire lost_arb;
	wire lrb;
    wire start_detect; 
    wire stop_detect; 
    wire clkgen_tc;
    wire clkgen_ce1; 
    wire clkgen_cl1;
    wire txdata;
    wire rxdata;
    wire stalled;
    wire busy;
	wire byte_complete;
    wire contention;
    wire clkgen_en;
    wire [2:0] cs_addr_clkgen;

	reg m_reset_reg;
	reg s_reset_reg;
	reg lost_arb_reg;

    /* Internal signal register type declaration*/
    reg bus_busy_reg;
    reg s_lrb_reg;
	reg m_lrb_reg;
    reg s_byte_complete_reg;
	reg m_byte_complete_reg;
    reg clkgen_tc1_reg; 
    reg clkgen_tc2_reg; 
    reg contention1_reg;
	reg master_mode_reg;
	reg m_sda_out_reg;
	reg m_scl_out_reg;
    
    /**************************************************************************/
    /* Signals for Slave                                                      */
    /**************************************************************************/
    wire [2:0] count;
    wire [3:0] foo;

    reg address_reg;
    reg start_sample_reg;
	reg start_sample1_reg;
	reg s_sda_out_reg;
	reg s_scl_out_reg;
   
    cy_psoc3_udb_clock_enable_v1_0 #(.sync_mode(`TRUE))
    ClkSync0(
        /* input  */ .clock_in(clock),
        /* input  */ .enable(op_clk_en),
		/* output */ .clock_out(op_clk)
    );

	/* The clock to operate Control Reg for ES3 must be synchronous and run
     * continuosly. In this case the udb_clock_enable is used only for 
     * synchronization. The resulted clock is always enabled.
     */ 
	cy_psoc3_udb_clock_enable_v1_0 #(.sync_mode(`TRUE))
    ClkSync1(
    	/* input  */ .clock_in(clock),
        /* input  */ .enable(1'b1),
		/* output */ .clock_out(clk0)
    );

    /* Instantiate the control register */
    generate
        if (PSOC3_ES2 || PSOC5_ES1)
        begin: AsyncCtl
	        cy_psoc3_control #(.cy_force_order(`TRUE)) 
            CtrlReg (
                /* output 07:00] */ .control(control)
            );
        end
        else
        begin: SyncCtl
            cy_psoc3_control #(.cy_force_order(`TRUE), .cy_ctrl_mode_1(8'h00), .cy_ctrl_mode_0(8'hFF))
            CtrlReg (
                /* input          */ .clock(clk0),
                /* output [07:00] */ .control(control)
            );
        end
    endgenerate
    
       
    /* Instantiate the status register and interrupt hook */
    cy_psoc3_statusi #(.cy_force_order(`TRUE), .cy_md_select(7'h20), .cy_int_mask(7'h00)) 
    StsReg (
    	/* input          */ .clock(op_clk),
		/* input          */ .reset(1'b0),
        /* input  [06:00] */ .status(status),
        /* output         */ .interrupt(irq)
    );
    
    /* Shifter.                                                               
     * Datapath is shifting into and out of A0.                               
     * User writes TX data to A0 and reads RX data from A0, always stalled.   
     * F1 status is used to synchronize start of transmission.                
     */
	cy_psoc3_dp8 #(.d0_init_a(I2C_DEFAULT_ADDR), 
	.cy_dpconfig_a(
    {
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM0:     IDLE */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC__ALU, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM1:     SHIFT A0 */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC_NONE, `CS_A1_SRC___F1,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM2:     LOAD A1 from F1 */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM3:      */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM4:    */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM5:      */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM6:      */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM7:     */
          8'hFF, 8'h00,    /*CFG9:      */
          8'hFF, 8'h7F,    /*CFG11-10:     Address Mask */
        `SC_CMPB_A0_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH,
        `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_ENBL,
        `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI,
        `SC_SI_A_ROUTE, /*CFG13-12:      */
        `SC_A0_SRC_ACC, `SC_SHIFT_SL, 1'h0,
        1'h0, `SC_FIFO1_BUS, `SC_FIFO0_BUS,
        `SC_MSB_DSBL, `SC_MSB_BIT7, `SC_MSB_NOCHN,
        `SC_FB_NOCHN, `SC_CMP1_NOCHN,
        `SC_CMP0_NOCHN, /*CFG15-14:      */
        3'h00, `SC_FIFO_SYNC_NONE, 6'h00,   
        `SC_FIFO_CLK__DP,`SC_FIFO_CAP_AX,
        `SC_FIFO__EDGE,`SC_FIFO_ASYNC,`SC_EXTCRC_DSBL,
        `SC_WRK16CAT_DSBL /*CFG17-16:      */
	})) Shifter(
	    	/* input            */ .reset(1'b0),
			/* input            */ .clk(op_clk),
	    	/* input	[02:00]	*/ .cs_addr(cs_addr_shifter),  
	    	/* input            */ .route_si(sda_in_reg),
	    	/* input            */ .route_ci(1'b0),
		    /* input            */ .f0_load(1'b0),
		    /* input            */ .f1_load(1'b0),
		    /* input            */ .d0_load(1'b0),
		    /* input            */ .d1_load(1'b0),
		    /* output           */ .ce0(), 
	        /* output           */ .ce0_reg(address_match),
		    /* output           */ .cl0(),
		    /* output           */ .z0(),
		    /* output           */ .ff0(),
		    /* output           */ .ce1(),
		    /* output           */ .cl1(),
		    /* output           */ .z1(),
		    /* output           */ .ff1(),
		    /* output           */ .ov_msb(),
		    /* output           */ .co_msb(),
		    /* output           */ .cmsb(),
		    /* output           */ .so(shift_data_out),
		    /* output           */ .f0_bus_stat(), 
		    /* output           */ .f0_blk_stat(),
		    /* output           */ .f1_bus_stat(), 
		    /* output           */ .f1_blk_stat(tx_reg_empty) 
    );

 	
    generate
        if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin: Master
            /* Clock Generator.                                                       
             * Use only for Master, MultiMaster and MultiMaster-Slave.              
             * Datapath is counting samples at divide by 8.                           
             * State changes on "tc".                                                 
             * Output clock is "cmpl0" (compare < 4).                                 
             */
            cy_psoc3_dp8 #(.d0_init_a(QUANTITY_OF_SAMPLES), .d1_init_a(HALF_QUANTITY_OF_SAMPLES), 
			.cy_dpconfig_a(
            {
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM0:     IDLE */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC__ALU, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM1:     DEC A0 */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM2:     IDLE */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC___D0, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM3:     LOAD A0 from D0 */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC___D0, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM4:     LOAD A0 from D0    */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC__ALU, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM5:     DEC A0 */
                `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM6:      */
                `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
                `CS_SHFT_OP_PASS, `CS_A0_SRC___D0, `CS_A1_SRC_NONE,
                `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
                `CS_CMP_SEL_CFGA, /*CFGRAM7:     LOAD A0 from D0 */
                  8'hFF, 8'h00,    /*CFG9:      */
                  8'hFF, 8'h7F,    /*CFG11-10:     Address Mask */
                `SC_CMPB_A0_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH,
                `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_ENBL,
                `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI,
                `SC_SI_A_ROUTE, /*CFG13-12:      */
                `SC_A0_SRC_ACC, `SC_SHIFT_SL, 1'h0,
                1'h0, `SC_FIFO1_BUS, `SC_FIFO0_BUS,
                `SC_MSB_DSBL, `SC_MSB_BIT7, `SC_MSB_NOCHN,
                `SC_FB_NOCHN, `SC_CMP1_NOCHN,
                `SC_CMP0_NOCHN, /*CFG15-14:      */
                3'h00, `SC_FIFO_SYNC__ADD, 6'h00,
                `SC_FIFO_CLK__DP,`SC_FIFO_CAP_AX,
                `SC_FIFO__EDGE,`SC_FIFO__SYNC,`SC_EXTCRC_DSBL,
                `SC_WRK16CAT_DSBL /*CFG17-16:      */
            })) ClkGen(
					/* input            */ .reset(1'b0),
	            	/* input            */ .clk(op_clk),
		            /* input	[02:00] */ .cs_addr(cs_addr_clkgen),
		            /* input            */ .route_si(1'b0),
		            /* input            */ .route_ci(1'b0),
		            /* input            */ .f0_load(1'b0),
		            /* input            */ .f1_load(1'b0),
		            /* input            */ .d0_load(1'b0),
		            /* input            */ .d1_load(1'b0),
		            /* output	        */ .ce0(),
		            /* output           */ .cl0(),
		            /* output           */ .z0(clkgen_tc),
		            /* output           */ .ff0(),
		            /* output           */ .ce1(clkgen_ce1),
		            /* output           */ .cl1(clkgen_cl1),
		            /* output           */ .cl1_reg(),
		            /* output           */ .z1(),
		            /* output           */ .ff1(),
		            /* output           */ .ov_msb(),
		            /* output           */ .co_msb(),
		            /* output           */ .cmsb(),
		            /* output           */ .so(),
		            /* output           */ .f0_bus_stat(), 
		            /* output           */ .f0_blk_stat(),
		            /* output           */ .f1_bus_stat() 
            );
        end
        if ((Mode == I2C_MODE_SLAVE)  || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin: Slave
            /* Used for bit counting for address and data shift in and out. */
            cy_psoc3_count7 #(.cy_period(QUANTITY_OF_BITS),.cy_route_ld(`TRUE),.cy_route_en(`TRUE)) 
			BitCounter(
            	/* input            */ .clock(op_clk),
                /* input            */ .reset(s_reset), 
                /* input            */ .load(counter_load),
                /* input            */ .enable(counter_en),
                /* output	[06:00] */ .count({foo,count}),
                /* output           */ .tc()
            );
        end
    endgenerate
    
    /* Control Register Implementation */
	generate
	if (PSOC3_ES2 || PSOC5_ES1)
        begin: SyncedCtlOutput

			/*Sync the Control register outputs to component clock*/
			always @(posedge clk0)
		    begin
         		control_reg[7:0] <= control[7:0];
    		end

			assign ctrl_stop_gen      = control_reg[I2C_CTRL_STOP_GEN];
   	 		assign ctrl_restart_gen   = control_reg[I2C_CTRL_RESTART_GEN];
    		assign ctrl_nack          = control_reg[I2C_CTRL_NACK];
    		assign ctrl_any_address   = control_reg[I2C_CTRL_ANY_ADDRESS];
    		assign ctrl_transmit      = control_reg[I2C_CTRL_TRANSMIT];
    		assign ctrl_master_en     = control_reg[I2C_CTRL_MASTER_EN];
    		assign ctrl_slave_en      = control_reg[I2C_CTRL_SLAVE_EN];
		end
	else
        begin: AsyncCtlOutput
			assign ctrl_stop_gen      = control[I2C_CTRL_STOP_GEN];
   	 		assign ctrl_restart_gen   = control[I2C_CTRL_RESTART_GEN];
    		assign ctrl_nack          = control[I2C_CTRL_NACK];
    		assign ctrl_any_address   = control[I2C_CTRL_ANY_ADDRESS];
    		assign ctrl_transmit      = control[I2C_CTRL_TRANSMIT];
    		assign ctrl_master_en     = control[I2C_CTRL_MASTER_EN];
    		assign ctrl_slave_en      = control[I2C_CTRL_SLAVE_EN];
		end
	endgenerate

    /* Status Register Implementation */
    assign status[I2C_STS_LOST_ARB]         = ((Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE)) ? lost_arb_reg : 1'b0; 
    assign status[I2C_STS_STOP]             = stop_detect;                                  												 	
    assign status[I2C_STS_BUS_BUSY]         = (Mode == I2C_MODE_SLAVE) ? 1'b0 : busy;  														
    assign status[I2C_STS_ADDRESS]          = ((Mode == I2C_MODE_SLAVE) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE)) ? address_reg : 1'b0;   		
    assign status[I2C_STS_MASTER_MODE]      = (Mode == I2C_MODE_SLAVE) ? 1'b0 : master_mode_reg; 											
    assign status[I2C_STS_LRB]              = ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER)) 	? m_lrb_reg :				
											  (Mode == I2C_MODE_MULTI_MASTER_SLAVE)                      		? (m_lrb_reg | s_lrb_reg) :
											  (Mode == I2C_MODE_SLAVE) 											? s_lrb_reg : 1'b0;       
 	assign status[I2C_STS_BYTE_COMPLETE]    = ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER)) 	? m_byte_complete_reg :			
											  (Mode == I2C_MODE_MULTI_MASTER_SLAVE)                      		? (m_byte_complete_reg | s_byte_complete_reg) :
											  (Mode == I2C_MODE_SLAVE) 											? s_byte_complete_reg : 1'b0;
                           						

    /**************************************************************************/
    /* Start/Stop Detect (Slave, MultiMaster and MultiMaster-Slave only).     */ 
    /* Not generated for simple Master                                        */
    /**************************************************************************/

    /* Need edge detect for start and stop */
    always @(posedge op_clk)
    begin
        sda_in_reg <= sda_in;
    end

    always @(posedge op_clk)
    begin
        scl_in_reg <= scl_in;
    end

    always @(posedge op_clk)
    begin
        sda_in1_reg <= sda_in_reg;
    end

    always @(posedge op_clk)
    begin
        scl_in1_reg <= scl_in_reg;
    end
	
    assign sda_negedge_detect = ~sda_in_reg & sda_in1_reg;
    assign sda_posedge_detect = sda_in_reg & ~sda_in1_reg;
    assign scl_negedge_detect = ~scl_in_reg & scl_in1_reg;
    assign scl_posedge_detect = scl_in_reg & ~scl_in1_reg;

    /* Compute Start and Stop                                                  */
    /* For Slave the Start detect resets all state in the block, this excepted */
    assign start_detect = (Mode != I2C_MODE_MASTER) ? (scl_in_reg & sda_negedge_detect) : 1'b0;
    assign stop_detect  = (Mode != I2C_MODE_MASTER) ? (scl_in_reg & sda_posedge_detect) : 1'b0;
   
    /**************************************************************************/
    /* Protocol State Machine.                                                */
    /* Includes states and byte complete computation.                         */
    /* State changes are aligned with input shifting which is on the positive */
    /* edge of SCL.                                                           */
    /* There are two flows: RX data/address, and TX data, and the address     */
    /* state bit distinguishes between RX data and address                    */
    /**************************************************************************/
	generate
    	if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin
            always @(posedge op_clk)
            begin
                if (m_reset) m_state <= I2C_MASTER_IDLE;
				else if (clkgen_tc1_reg)
                	begin
                			case (m_state)
	                			I2C_MASTER_IDLE:
	                			begin
	                    			if (~tx_reg_empty & ~busy) m_state <= I2C_MASTER_PRE_START;
	                    			else                       m_state <= I2C_MASTER_IDLE;
	                			end

	                			I2C_MASTER_PRE_START:	m_state <= I2C_MASTER_START;
	                			I2C_MASTER_START:		m_state <= I2C_MASTER_TX_D0;
	                			I2C_MASTER_TX_D0:		m_state <= I2C_MASTER_TX_D1;
	                			I2C_MASTER_TX_D1:		m_state <= I2C_MASTER_TX_D2;
	                			I2C_MASTER_TX_D2:		m_state <= I2C_MASTER_TX_D3;
	                			I2C_MASTER_TX_D3:		m_state <= I2C_MASTER_TX_D4;
	                			I2C_MASTER_TX_D4:		m_state <= I2C_MASTER_TX_D5;
	                			I2C_MASTER_TX_D5:		m_state <= I2C_MASTER_TX_D6;
	                			I2C_MASTER_TX_D6:		m_state <= I2C_MASTER_TX_D7;
	                			I2C_MASTER_TX_D7:		if (lost_arb_reg & address_reg & address_match & ~ctrl_any_address &
															(Mode == I2C_MODE_MULTI_MASTER_SLAVE)) 	m_state <= I2C_MASTER_IDLE;
														else 										m_state <= I2C_MASTER_TX_ACK;
	                			I2C_MASTER_TX_ACK: 													m_state <= I2C_MASTER_TX_STALL;

	                			/* This could be on address ACK or data ACK */
	                			I2C_MASTER_TX_STALL:
	                			begin
	                    			if (~tx_reg_empty)
	                    			begin
	                        			if (lost_arb_reg)			m_state <= I2C_MASTER_IDLE;
										else if (ctrl_stop_gen) 	m_state <= I2C_MASTER_STOP;
	                        			else if (ctrl_restart_gen) 	m_state <= I2C_MASTER_RESTART;
	                        			else if (ctrl_transmit)     m_state <= I2C_MASTER_TX_D0;
	                            		else 			            m_state <= I2C_MASTER_RX_D0;
	                        		end
	                    	        else 	                        m_state <= I2C_MASTER_TX_STALL;
	                			end

	                			I2C_MASTER_RX_D0:	m_state <= I2C_MASTER_RX_D1;
	                			I2C_MASTER_RX_D1:	m_state <= I2C_MASTER_RX_D2;
	                			I2C_MASTER_RX_D2:	m_state <= I2C_MASTER_RX_D3;
	                			I2C_MASTER_RX_D3:	m_state <= I2C_MASTER_RX_D4;
	                			I2C_MASTER_RX_D4:	m_state <= I2C_MASTER_RX_D5;
	                			I2C_MASTER_RX_D5:	m_state <= I2C_MASTER_RX_D6;
	                			I2C_MASTER_RX_D6:	m_state <= I2C_MASTER_RX_D7;
	                			I2C_MASTER_RX_D7: 	m_state <= I2C_MASTER_RX_STALL;
	                			
	                			I2C_MASTER_RX_STALL: 
	                			begin
									if (~tx_reg_empty)	
									begin 
										if (lost_arb_reg)	m_state <= I2C_MASTER_IDLE;
										else 				m_state <= I2C_MASTER_RX_ACK;
									end
	                    			else					m_state <= I2C_MASTER_RX_STALL;
	                			end 

	                			I2C_MASTER_RX_ACK: 
	                			begin
									if (ctrl_nack & ~lost_arb)     
	                    			begin
	                        			if (ctrl_restart_gen)	m_state <= I2C_MASTER_RESTART;
	                        			else                	m_state <= I2C_MASTER_STOP;
	                    			end
	                    			else if (lost_arb_reg) 		m_state <= I2C_MASTER_IDLE;
									else						m_state <= I2C_MASTER_RX_D0;
	                			end 

	                			/* Need this state to setup the start SDA goes high from whereever it was */
	                			I2C_MASTER_RESTART:	m_state <= I2C_MASTER_START;
	                			
	                			/* Generate STOP hold time */
	                			I2C_MASTER_STOP:	m_state <= I2C_MASTER_IDLE; 
                			endcase
                	end
            end
        end
        if ((Mode == I2C_MODE_SLAVE) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin
        	always @(posedge op_clk)
            begin
                if (s_reset) 
                begin
                    s_state <= I2C_SLAVE_IDLE;
                    s_byte_complete_reg <= 1'b0;
                end
                else
                begin
                 	if (s_load_dummy) s_byte_complete_reg <= 1'b0;
                	
					case (s_state)
                  		/* Stay in IDLE state until start signal is detected */
                		I2C_SLAVE_IDLE: 
                		begin
                    		if (start_sample1_reg) 	s_state <= I2C_SLAVE_RX_DATA;
                    		else       				s_state <= I2C_SLAVE_IDLE;
                		end

		                /* WRITE (address or data)
		                 * The address state bit is used to distinguish
		                 * If an address and a match (or any address), stall, otherwise idle
						 */
						I2C_SLAVE_RX_DATA: 
                		begin
                    		if (scl_posedge_detect && count_eq_zero) 
                    		begin
                        		if (!address_reg | (address_reg & (address_match | ctrl_any_address))) 
                        		begin
                            		s_byte_complete_reg <= 1'b1;
                            		s_state <= I2C_SLAVE_RX_STALL;
                        		end
                        		else s_state <= I2C_SLAVE_IDLE;
                    		end
                    		else s_state <= I2C_SLAVE_RX_DATA;
                		end
                
		                /* Local CPU is reading address and deciding what to do, tx or rx, etc
		                 * Wait for a dummy write to the tx registe to start either read or write
		                 * If a write, local CPU can NACK... better not do this on address state 
						 */
                		I2C_SLAVE_RX_STALL: 
                		begin
                    		if (scl_in_reg == 1'b0 & ~tx_reg_empty) 
                    		begin
                    			/* foo - go to ACK then idle? to be compatible wiht master
                       			 * would need to also change sda_out computation if this changes (ctrl_nack) 
								 */
                        		if (ctrl_nack) 	s_state <= I2C_SLAVE_IDLE;
                        		else			s_state <= I2C_SLAVE_RX_ACK;
                    		end
                    		else 				s_state <= I2C_SLAVE_RX_STALL;
                		end 

                		/* ACK the received address or data */
                		I2C_SLAVE_RX_ACK: 
                		begin
                    		if (scl_posedge_detect)
                    		begin
                        		if (ctrl_transmit) 	s_state <= I2C_SLAVE_TX_DATA; 
                        		else 				s_state <= I2C_SLAVE_RX_DATA;
                    		end
                    		else 					s_state <= I2C_SLAVE_RX_ACK;
                		end 

                		/* READ 8-bits of data is shifting out */
                		I2C_SLAVE_TX_DATA: 
                		begin
                    		if (scl_posedge_detect & count_eq_zero) s_state <= I2C_SLAVE_TX_ACK;
                    		else									s_state <= I2C_SLAVE_TX_DATA;
                		end	

		                /* Check for the ACK from the external master
		                 * If it's a NACK, then idle 
						 */
                		I2C_SLAVE_TX_ACK: 
                		begin
                    		if (scl_posedge_detect)  
                    		begin
                        		s_byte_complete_reg <= 1'b1;
                        		s_state <= I2C_SLAVE_TX_STALL;
                    		end
                		end

                		/* External master ACKed, so it wants more bytes */
                		I2C_SLAVE_TX_STALL: 
                		begin
                    		if (scl_in_reg == 1'b0  & ~tx_reg_empty)	s_state <= I2C_SLAVE_TX_DATA;  
                    		else										s_state <= I2C_SLAVE_TX_STALL;
                		end
                	endcase
              	end
            end
        end
    endgenerate
    
	/*************************************************************************/
    /* Bit Controller.                                                       */
    /*************************************************************************/
    generate
        if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin
            /* Master SCL out */
            always @(posedge op_clk)
            begin
                if (m_reset)												m_scl_out_reg <= 1'b1;
                else if (stalled)											m_scl_out_reg <= 1'b0;
                else if (m_state == I2C_MASTER_RESTART & clkgen_tc1_reg)	m_scl_out_reg <= 1'b1;
                else if (m_state == I2C_MASTER_START & clkgen_tc1_reg)      m_scl_out_reg <= clkgen_cl1;
                else if (m_state == I2C_MASTER_STOP & clkgen_tc1_reg)       m_scl_out_reg <= 1'b1;
                else if ((m_state != I2C_MASTER_IDLE) && 
						 (m_state != I2C_MASTER_START) && 
						 (m_state != I2C_MASTER_PRE_START))                 m_scl_out_reg <= clkgen_cl1;
                else												        m_scl_out_reg <= 1'b1;
            end
            
            /* Master SDA out */
            always @(posedge op_clk)
            begin
                if (m_reset) 																m_sda_out_reg <= 1'b1;
                else if (clkgen_tc2_reg)     
                    begin
                        if ((m_state == I2C_MASTER_START) || 
							(m_state == I2C_MASTER_STOP) || 
							(m_state == I2C_MASTER_RX_ACK & ~ctrl_nack & ~lost_arb_reg))	m_sda_out_reg <= 1'b0;
                        else if (txdata & ~lost_arb_reg) 									m_sda_out_reg <= shift_data_out;
                        else 																m_sda_out_reg <= 1'b1;
                    end
            end
        end
        if ((Mode == I2C_MODE_SLAVE)  || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin
            /* Compute SCL_OUT for stalling
             * once scl_out goes low it's "latched" because the master stops
             * released when we change state because of a FIFO write
             */   
            always @(posedge op_clk)
            begin
                if (s_reset) 													s_scl_out_reg <= 1'b1;
                else if (s_state == I2C_SLAVE_RX_STALL & scl_in_reg == 1'b0)	s_scl_out_reg <= 1'b0;
                else if (s_state == I2C_SLAVE_TX_STALL & scl_in_reg == 1'b0)    s_scl_out_reg <= 1'b0;
                else								                        	s_scl_out_reg <= 1'b1;
            end

            /* Compute SDA out change only on the negative edge of SCL */
            always @(posedge op_clk)
            begin
                if (s_reset) 																	s_sda_out_reg <= 1'b1;
                else if (scl_negedge_detect | scl_out == 1'b0) /* Output data only on the negative edge or if the clock is low */
                	begin
                       	if (s_state == I2C_SLAVE_TX_STALL | s_state == I2C_SLAVE_TX_DATA)		s_sda_out_reg <= shift_data_out;
                       	else if (s_state == I2C_SLAVE_RX_STALL | s_state == I2C_SLAVE_RX_ACK)	s_sda_out_reg <= 1'b0;
                       	else											                        s_sda_out_reg <= 1'b1;
                    end
            end
        end
    endgenerate

    generate
        if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin
            
			/* Need to manually register TC until we can have both 
             * registered and combo version out
             */
            always @(posedge op_clk)
            begin
                if (m_reset) clkgen_tc1_reg <= 1'b1;
                else         clkgen_tc1_reg <= clkgen_tc;
            end

            /* Delayed so data can be changed one cycle after clock for hold */
            always @(posedge op_clk)
            begin
                if (m_reset) clkgen_tc2_reg <= 1'b1;
                else         clkgen_tc2_reg <= clkgen_tc1_reg;
            end
            
			/* Byte complete.                                                         
             * Need it to match the Fixed Function implementation.                    
             * So instead of a pulse that is capture by sticky register we have a     
             * sticky register in PLD that is cleared by GO                           
             */
            always @(posedge op_clk)
            begin
                if (m_reset)                                m_byte_complete_reg <= 1'b0;
                else if (m_load_dummy)                      m_byte_complete_reg <= 1'b0;
                else if (m_state == I2C_MASTER_TX_STALL || 
						 m_state == I2C_MASTER_RX_STALL)	m_byte_complete_reg <= 1'b1;
            end

			/* This bit is set/cleared when the device is operating as a master. 
			 * '0' stop condition detected, generated by this device. 
             * '1'  start condition detected, generated by this device. 
			 */
			always @(posedge op_clk)
            begin
                if (m_reset)           				  	master_mode_reg <= 1'b0;
				else if (m_state == I2C_MASTER_IDLE)  	master_mode_reg <= 1'b0;
                else if (m_state == I2C_MASTER_STOP)  	master_mode_reg <= 1'b0;
                else if (m_state == I2C_MASTER_START)	master_mode_reg <= 1'b1;
            end

            /* LRB (last received bit, which is ACK/NACK from the slave on WRITE command */
            always @(posedge op_clk)
            begin
                if (m_reset)                             				m_lrb_reg <= 1'b0;
                else if (clkgen_tc1_reg & m_state == I2C_MASTER_TX_ACK)	m_lrb_reg <= sda_in;
            end

            /* Do positive edge detect on contention goes to FSM (to IDLE), and sticky status register */
            always @(posedge op_clk)
            begin
                if (m_reset) contention1_reg <= 1'b0;
                else         contention1_reg <= contention; 
            end

			always @(posedge op_clk)
            begin
                if (m_reset) 												lost_arb_reg <= 1'b0;
				else if (m_load_dummy)										lost_arb_reg <= 1'b0;
				else if (m_state == I2C_MASTER_IDLE)						lost_arb_reg <= 1'b0; /* Need this for clear lost_arb in MultiMater-Slave mode*/
                else if (lost_arb)											lost_arb_reg <= 1'b1;
            end
			 
            assign lost_arb = (contention & ~contention1_reg);

			/* Busy computation
             * Simple decode of IDLE for single master, use start and stop detect for multi master mode   
             */
            always @(posedge op_clk)
            begin
                if (m_reset) bus_busy_reg <= 1'b0;
                else         bus_busy_reg <= (start_detect | bus_busy_reg) & !stop_detect; 
            end
            
            
			always @(posedge op_clk)
    		begin
        		m_reset_reg <= reset;
		    end

			/**************************************************************************
            * Combinational signals                                                  
            ***************************************************************************/
            /* Compute Master reset */
            assign m_reset = m_reset_reg;

            assign busy = ((Mode == I2C_MODE_MULTI_MASTER) || 
                           (Mode == I2C_MODE_MULTI_MASTER_SLAVE)) ? bus_busy_reg : (m_state != I2C_MASTER_IDLE);


            /* Contention (multimaster only)
             * Optimized out for simple master
             */
            /* check for contention at the sample points, when the master is transmitting */
			assign contention = clkgen_tc1_reg & (txdata | m_state == I2C_MASTER_RX_ACK) & (sda_in_reg != sda_out);
			
            /* State decodes for convenience */
            assign rxdata = m_state == I2C_MASTER_RX_D0 |
                            m_state == I2C_MASTER_RX_D1 |
                            m_state == I2C_MASTER_RX_D2 |
                            m_state == I2C_MASTER_RX_D3 |
                            m_state == I2C_MASTER_RX_D4 |
                            m_state == I2C_MASTER_RX_D5 |
                            m_state == I2C_MASTER_RX_D6 |
                            m_state == I2C_MASTER_RX_D7;

            assign txdata = m_state == I2C_MASTER_TX_D0 |
                            m_state == I2C_MASTER_TX_D1 |
                            m_state == I2C_MASTER_TX_D2 |
                            m_state == I2C_MASTER_TX_D3 |
                            m_state == I2C_MASTER_TX_D4 |
                            m_state == I2C_MASTER_TX_D5 |
                            m_state == I2C_MASTER_TX_D6 |
                            m_state == I2C_MASTER_TX_D7;

            assign stalled = (m_state == I2C_MASTER_TX_STALL | m_state == I2C_MASTER_RX_STALL);

			/* Sigmals for control ClkGen module*/ 
 			assign clkgen_en = (scl_in_reg == scl_out) & ((m_state == I2C_MASTER_IDLE & ~tx_reg_empty) | (m_state != I2C_MASTER_IDLE));
            assign cs_addr_clkgen = {1'b0, clkgen_tc, clkgen_en};
			
		 	/* Compute when to continue transfer, CPU signals this with a write to FIFO F1.
             * This is dummy data, it isn't used, its loaded into A1.
             */    
			assign m_load_dummy = (~tx_reg_empty & clkgen_tc1_reg);
			 
			/* Compute when to enable shifting */
			assign m_shift_en = clkgen_tc & (rxdata | txdata);   
        end
        if ((Mode == I2C_MODE_SLAVE) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
        begin    
            
			/* LRB (last received bit, which is ACK/NACK from the master on WRITE command */
            always @(posedge op_clk)
            begin
                if (s_reset)                                         		s_lrb_reg <= 1'b0;
                else if (scl_posedge_detect & s_state == I2C_SLAVE_TX_ACK ) s_lrb_reg <= sda_in_reg;
            end

            /* The start detect resets all state in the block, this excepted */
            always @(posedge op_clk)
            begin
                start_sample_reg <= start_detect;
            end

            always @(posedge op_clk)
            begin
                start_sample1_reg <= start_sample_reg;
            end

            /* Address bit distinguish the address reception from data reception
               This is sticky until the user writes to continue the transfer */
            always @(posedge op_clk)
            begin
              if (s_reset) address_reg <= 1'b0;
              else    	   address_reg <= (start_sample1_reg | address_reg) & tx_reg_empty;
            end
			
			always @(posedge op_clk)
    		begin
        		s_reset_reg <= start_detect | reset;
		    end

            /* Compute Slave reset */
			assign s_reset = s_reset_reg;
            
            /* Compute when to reload bit counter */
            assign counter_load = (s_state == I2C_SLAVE_RX_ACK) | (s_state == I2C_SLAVE_TX_ACK);

            /* Compute when to count */
			assign counter_en = start_sample1_reg | s_shift_en;

            assign count_eq_zero = (count == 3'b0);

     		assign s_load_dummy = (scl_in_reg == 1'b0) & ~tx_reg_empty & (s_state == I2C_SLAVE_RX_STALL | s_state == I2C_SLAVE_TX_STALL);
			assign s_shift_en = scl_posedge_detect & (s_state == I2C_SLAVE_RX_DATA | s_state == I2C_SLAVE_TX_DATA);
        end
    endgenerate

	generate
       if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER))
        begin
			assign sda_out = m_sda_out_reg;
			assign scl_out = m_scl_out_reg;
			assign cs_addr_shifter = {1'b0, m_load_dummy , m_shift_en};
		end
 		else if (Mode == I2C_MODE_MULTI_MASTER_SLAVE)
        begin
			assign sda_out =  m_sda_out_reg & s_sda_out_reg;
			assign scl_out =  m_scl_out_reg & s_scl_out_reg;
			assign cs_addr_shifter = {1'b0, (m_load_dummy | s_load_dummy), (m_shift_en | (s_shift_en & ~master_mode_reg))};
		end
 		else if (Mode == I2C_MODE_SLAVE)
        begin
			assign sda_out = s_sda_out_reg;
			assign scl_out = s_scl_out_reg;
			assign cs_addr_shifter = {1'b0, s_load_dummy, s_shift_en};
		end
	endgenerate

	/* This signal is used for enable of cy_psoc3_udb_clock_enable_v1_0 */
	assign op_clk_en = ctrl_master_en | ctrl_slave_en;
	
endmodule /* bI2C_v2_10 */ 
`endif /* bI2C_v2_10_V_ALREADY_INCLUDED */
