/*******************************************************************************
* File Name: bI2C_v3_20.v
* Version `$CY_MAJOR_VERSION`.`$CY_MINOR_VERSION`
*
* Description:
*  This file provides a base model of the I2C componnent defining and all of the
*  necessary interconnect.
*
********************************************************************************
*                 Control and Status Register definitions
********************************************************************************
* Control Register Definition
*  +=====+---------+--------+-----------+--------+----------+--------+---------+--------+
*  | Bit |  7      |   6    |     5     |   4    |    3     |    2   |    1    |   0    |
*  +=====+---------+--------+-----------+--------+----------+--------+---------+--------+
*  | Name|start_gen|stop_gen|restart_gen|  ack   |hw_addr_en|transmit|master_en|slave_en|
*  +=====+---------+--------+-----------+--------+----------+--------+---------+--------+
*
*   slave_en     => 0 = Slave mode is disabled
*                   1 = Slave mode is enabled
*
*   master_en   =>  0 = Master mode is disabled
*                   1 = Master mode is enabled
*
*   transmit    =>  0 = Bytes are received from the component
*                   1 = Bytes are transferred from the component
*
*   hw_addr_en  =>  0 = HW Address comparison is enabled
*                   1 = HW Address comparison is disabled
*
*   ack         =>  0 = nack the last received byte
*                   1 = ack the last received byte
*
*   restart_gen =>  0 = not generate a Restart condition
*                   1 = generate a Restart condition
*
*   stop_gen    =>  0 = not generate a Stop condition
*                   1 =  generate a Stop condition
*
*   start_gen   =>  0 = not generate a Start condition
*                   1 = generate a Start condition
*
*  Status Register Definition
*  +=======+---------+-----------+-----------+-----------+------------+-----------+-----------+-------------+
*  |  Bit  |    7    |     6     |     5     |     4     |     3      |     2     |      1    |     0       |
*  +=======+---------+-----------+-----------+-----------+------------+-----------+-----------+-------------+
*  | Mode  |   none  |transparent|  sticky   |transparent|transparent |transparent|transparent| transparent |
*  +=======+---------+-----------+-----------+-----------+------------+-----------+-----------+-------------+
*  | Name  |interrupt|  lost_arb |stop_status|  bus_busy |   address  |master_mode|    lrb    |byte_complete|
*  +=======+---------+-----------+-----------+-----------+------------+-----------+-----------+-------------+
*
*   byte_complete   =>  0 = no completed transmit/receive
*                       1 = eight bits of data have been transmitted/received
*
*   lrb             =>  0 = last transmitted byte was ACK'ed by the receiver
*                       1 = last transmitted byte was NACK'ed by the receiver
*
*   master_mode     =>  0 = stop condition detected, generated by this component
*                       1 = start condition detected, generated by this component
*
*   address         =>  0 = the received byte is not a slave address
*                       1 = the received byte is a slave address
*
*   bus_busy        =>  0 = when a Stop condition is detected (from any bus master)
*                       1 = when a Start condition is detected (from any bus master)
*
*   stop_status     =>  0 = a Stop condition was not detected
*                       1 = a Stop condition was detected
*
*   lost_arb        =>  0 = lost Arbitration event
*                       1 = lost Arbitration
********************************************************************************
*           Data Path register definitions
********************************************************************************
*  INSTANCE NAME: Shifter
*  DESCRIPTION: Use for transmit/receive data
*  REGISTER USAGE:
*   F0 => na
*   F1 => component API mades dummy load for synchronisation start of transmission
*   D0 => na
*   D1 => na
*   A0 => user writes TX data to A0 and reads RX data from A0
*   A1 => na
*
*********************************************************************************
*  INSTANCE NAME:  ClkGen
*  DESCRIPTION: Clock Generator
*  REGISTER USAGE:
*   F0 => na
*   F1 => na
*   D0 => contains quantity of samples
*   D1 => contains half quantity of samples
*   A0 => decremental counter
*   A1 => na
*
********************************************************************************
*           I*O Signals:
********************************************************************************
*    name              direction       Description
*    clock               input          clock the component is running on
*    reset               input          reset signal
*    scl_in              input          I2C input clock signal
*    sda_in              input          I2C input data signal
*    sda_out             output         I2C output data signal
*    scl_out             output         I2C output clock signal
*    interrupt           output         interrupt signal
*
********************************************************************************
* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
* You may use this file only in accordance with the license, terms, conditions,
* disclaimers, and limitations in the end user license agreement accompanying
* the software package with which this file was provided.
********************************************************************************/

`include "cypress.v"
`ifdef bI2C_v3_20_V_ALREADY_INCLUDED
`else
`define bI2C_v3_20_V_ALREADY_INCLUDED

module bI2C_v3_20
(
    input wire clock,
    input wire reset,
    input wire scl_in,
    input wire sda_in,
    output wire sda_out,
    output wire scl_out,
    output wire interrupt
);

    localparam I2C_MODE_SLAVE               = 3'h1;
    localparam I2C_MODE_MASTER              = 3'h2;
    localparam I2C_MODE_MULTI_MASTER        = 3'h6;
    localparam I2C_MODE_MULTI_MASTER_SLAVE  = 3'h7;

    parameter [2:0] Mode = I2C_MODE_SLAVE;

    localparam I2C_DEFAULT_ADDR = 8'h04;
    localparam QUANTITY_OF_BITS = 8'd7;
    localparam QUANTITY_OF_SAMPLES = 8'd15;
    localparam HALF_QUANTITY_OF_SAMPLES = 8'd8;

    localparam I2C_CTRL_START_GEN   = 3'h7; /* generate a Start condition */
    localparam I2C_CTRL_STOP_GEN    = 3'h6; /* generate a Stop condition*/
    localparam I2C_CTRL_RESTART_GEN = 3'h5; /* generate a restart */
    localparam I2C_CTRL_NACK        = 3'h4; /* 1 = NAK on read, 0 = another byte */
    localparam I2C_CTRL_HW_ADDR_EN  = 3'h3; /* interrupt on any address */
    localparam I2C_CTRL_TRANSMIT    = 3'h2; /* 1 = transmit, 0 = receive */
    localparam I2C_CTRL_MASTER_EN   = 3'h1; /* enable master */
    localparam I2C_CTRL_SLAVE_EN    = 3'h0; /* enable slave*/

    localparam I2C_STS_LOST_ARB      = 3'h6;
    localparam I2C_STS_STOP          = 3'h5;
    localparam I2C_STS_BUS_BUSY      = 3'h4;
    localparam I2C_STS_ADDRESS       = 3'h3;
    localparam I2C_STS_MASTER_MODE   = 3'h2;
    localparam I2C_STS_LRB           = 3'h1;
    localparam I2C_STS_BYTE_COMPLETE = 3'h0;

    /* Master state mashine states */
    localparam I2C_MASTER_IDLE      = 5'h0;
    localparam I2C_MASTER_PRE_START = 5'h1;
    localparam I2C_MASTER_WAIT      = 5'h2;
    localparam I2C_MASTER_START     = 5'h3;
    localparam I2C_MASTER_RESTART   = 5'h4;
    localparam I2C_MASTER_STOP      = 5'h5;
    localparam I2C_MASTER_RX_STALL  = 5'h6;
    localparam I2C_MASTER_TX_STALL  = 5'h7;
    localparam I2C_MASTER_TX_D0     = 5'h8;
    localparam I2C_MASTER_TX_D1     = 5'h9;
    localparam I2C_MASTER_TX_D2     = 5'hA;
    localparam I2C_MASTER_TX_D3     = 5'hB;
    localparam I2C_MASTER_TX_D4     = 5'hC;
    localparam I2C_MASTER_TX_D5     = 5'hD;
    localparam I2C_MASTER_TX_D6     = 5'hE;
    localparam I2C_MASTER_TX_D7     = 5'hF;
    localparam I2C_MASTER_RX_D0     = 5'h10;
    localparam I2C_MASTER_RX_D1     = 5'h11;
    localparam I2C_MASTER_RX_D2     = 5'h12;
    localparam I2C_MASTER_RX_D3     = 5'h13;
    localparam I2C_MASTER_RX_D4     = 5'h14;
    localparam I2C_MASTER_RX_D5     = 5'h15;
    localparam I2C_MASTER_RX_D6     = 5'h16;
    localparam I2C_MASTER_RX_D7     = 5'h17;
    localparam I2C_MASTER_RX_ACK    = 5'h18;
    localparam I2C_MASTER_TX_ACK    = 5'h19;

    /* Slave state mashine states. Gray code. */
    localparam I2C_SLAVE_IDLE       = 3'h0;
    localparam I2C_SLAVE_RX_DATA    = 3'h1;
    localparam I2C_SLAVE_RX_STALL   = 3'h3;
    localparam I2C_SLAVE_RX_ACK     = 3'h2;
    localparam I2C_SLAVE_TX_DATA    = 3'h6;
    localparam I2C_SLAVE_TX_ACK     = 3'h7;
    localparam I2C_SLAVE_TX_STALL   = 3'h5;


    /* UDB Revision definitions*/
    localparam CY_UDB_V0 = (`CYDEV_CHIP_MEMBER_USED == `CYDEV_CHIP_MEMBER_5A);
    localparam CY_UDB_V1 = (!CY_UDB_V0);


    /* Common Signals for Master and Slave */
    wire op_clk;

    wire ctrl_start_gen;
    wire ctrl_stop_gen;
    wire ctrl_restart_gen;
    wire ctrl_nack;
    wire ctrl_hw_addr_en;
    wire ctrl_transmit;
    wire ctrl_master_en;
    wire ctrl_slave_en;

    wire s_load_dummy;
    wire m_load_dummy;
    wire s_shift_en;
    wire m_shift_en;
    wire shift_data_out;
    wire tx_reg_empty;
    wire address_match;
    wire s_reset;
    wire m_reset;
    wire irq_final;
    wire bus_busy;
    wire [2:0] count;
    wire [3:0] foo;


    wire [2:0] cs_addr_shifter;
    wire [6:0] status;
    wire [7:0] control;

    /* Internal registers */
    reg         sda_in_reg;
    reg         scl_in_reg;
    reg [7:2]   control_reg;
    reg [4:0]   m_state;
    reg [2:0]   s_state;


    /* Signals for Master */
    wire counter_en;
    wire counter_eq_zero;

    wire lost_arb;
    wire lrb;
    wire start_detect;
    wire stop_detect;
    wire clkgen_tc;
    wire clkgen_ce1;
    wire clkgen_cl1;
    wire txdata;
    wire rxdata;
    wire stalled;
    wire byte_complete;
    wire contention;
    wire clkgen_en;
    wire [2:0] cs_addr_clkgen;
    wire sts_irq;
    reg master_rst_reg;
    reg lost_arb_reg;
    reg lost_arb2_reg;
    reg irq_reg;
    reg bus_busy_reg;
    reg s_lrb_reg;
    reg m_lrb_reg;
    reg s_byte_complete_reg;
    reg m_byte_complete_reg;
    reg clkgen_tc1_reg;
    reg clkgen_tc2_reg;
    reg contention1_reg;
    reg master_mode_reg;
    reg m_sda_out_reg;
    reg m_scl_out_reg;
    reg m_address_reg;

    /**************************************************************************/
    /* Signals for Slave                                                      */
    /**************************************************************************/
    reg s_address_reg;
    reg start_sample0_reg;
    reg start_sample_reg;
    reg s_sda_out_reg;
    reg s_scl_out_reg;
    reg clk_eq_reg;
    wire cnt_reset;
    reg slave_rst_reg;
    reg scl_in_last_reg;
    reg scl_in_last2_reg;
    reg sda_in_last_reg;
    reg sda_in_last2_reg;
    wire sda_went_low;
    wire sda_went_high;
    wire scl_went_low;
    wire scl_went_high;

    /***************************************************************************
    * Instantiation of udb_clock_enable
    ****************************************************************************
    * The udb_clock_enable primitive component allows to support clock enable
    * mechanism and specify the intended synchronization behaviour for the clock
    * result (operational clock).
    ****************************************************************************/
    cy_psoc3_udb_clock_enable_v1_0 #(.sync_mode(`TRUE))
    ClkSync0(
        /* input  */ .clock_in  (clock),
        /* input  */ .enable    (1'b1),
        /* output */ .clock_out (op_clk)
    );

    /***************************************************************************
    * Instantiation of Control Register
    ***************************************************************************/
    generate
    if (CY_UDB_V0)
    begin: AsyncCtl
        cy_psoc3_control #(.cy_force_order(`TRUE))
        CtrlReg (
            /* output [07:00] */ .control (control)
        );
    end /* AsyncCtl */
    else
    begin: SyncCtl
        cy_psoc3_control #(.cy_force_order(`TRUE), .cy_ctrl_mode_1(8'h00), .cy_ctrl_mode_0(8'hFF))
        CtrlReg (
            /* input          */ .clock   (op_clk),
            /* output [07:00] */ .control (control)
        );
    end /* SyncCtl */
    endgenerate

    /***************************************************************************
    * Instantiate the status register and interrupt hook
    ***************************************************************************/
    cy_psoc3_statusi #(.cy_force_order (`TRUE), .cy_md_select (7'h20), .cy_int_mask (7'h00))
    StsReg(
        /* input          */ .clock     (op_clk),
        /* input          */ .reset     (1'b0),
        /* input  [06:00] */ .status    (status),
        /* output         */ .interrupt (sts_irq)
    );

    /***************************************************************************
    * Shifter
    ****************************************************************************
    * Datapath is shifting into and out of A0.
    * User writes TX data to A0 and reads RX data from A0, always stalled.
    * F1 status is used to synchronize start of transmission.
    ****************************************************************************/
    cy_psoc3_dp8 #(.d0_init_a(I2C_DEFAULT_ADDR),
    .cy_dpconfig_a(
    {
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM0:           IDLE */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC__ALU, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM1:           SHIFT A0 */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_A0,
        `CS_SHFT_OP___SL, `CS_A0_SRC_NONE, `CS_A1_SRC___F1,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM2:           LOAD A1 from F1 */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM3:            */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM4:          */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM5:            */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM6:            */
        `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
        `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
        `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
        `CS_CMP_SEL_CFGA, /*CFGRAM7:           */
          8'hFF, 8'h00,    /*CFG9:            */
          8'hFF, 8'h7F,    /*CFG11-10:           Address Mask */
        `SC_CMPB_A0_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH,
        `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_ENBL,
        `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI,
        `SC_SI_A_ROUTE, /*CFG13-12:            */
        `SC_A0_SRC_ACC, `SC_SHIFT_SL, 1'h0,
        1'h0, `SC_FIFO1_BUS, `SC_FIFO0_BUS,
        `SC_MSB_DSBL, `SC_MSB_BIT7, `SC_MSB_NOCHN,
        `SC_FB_NOCHN, `SC_CMP1_NOCHN,
        `SC_CMP0_NOCHN, /*CFG15-14:            */
        3'h00, `SC_FIFO_SYNC_NONE, 6'h00,
        `SC_FIFO_CLK__DP,`SC_FIFO_CAP_AX,
        `SC_FIFO__EDGE,`SC_FIFO_ASYNC,`SC_EXTCRC_DSBL,
        `SC_WRK16CAT_DSBL /*CFG17-16:            */
    })) Shifter(
        /* input          */ .reset         (1'b0),
        /* input          */ .clk           (op_clk),
        /* input  [02:00] */ .cs_addr       (cs_addr_shifter),
        /* input          */ .route_si      (sda_in_reg),
        /* input          */ .route_ci      (1'b0),
        /* input          */ .f0_load       (1'b0),
        /* input          */ .f1_load       (1'b0),
        /* input          */ .d0_load       (1'b0),
        /* input          */ .d1_load       (1'b0),
        /* output         */ .ce0           (),
        /* output         */ .ce0_reg       (address_match),
        /* output         */ .cl0           (),
        /* output         */ .z0            (),
        /* output         */ .ff0           (),
        /* output         */ .ce1           (),
        /* output         */ .cl1           (),
        /* output         */ .z1            (),
        /* output         */ .ff1           (),
        /* output         */ .ov_msb        (),
        /* output         */ .co_msb        (),
        /* output         */ .cmsb          (),
        /* output         */ .so            (shift_data_out),
        /* output         */ .f0_bus_stat   (),
        /* output         */ .f0_blk_stat   (),
        /* output         */ .f1_bus_stat   (),
        /* output         */ .f1_blk_stat   (tx_reg_empty)
    );

    generate
    if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin: Master
        /***************************************************************************
        * Clock Generator
        ****************************************************************************
        * Use only for Master, MultiMaster and MultiMaster-Slave.
        * Datapath is counting samples at divide by 8. State changes on "tc".
        * Output clock is "cmpl0" (compare < 4).
        ****************************************************************************/
        cy_psoc3_dp8 #(.d0_init_a(QUANTITY_OF_SAMPLES), .d1_init_a(HALF_QUANTITY_OF_SAMPLES),
        .cy_dpconfig_a(
        {
            `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM0:  IDLE*/
            `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC__ALU, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM1:  DEC A0 */
            `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC___D0, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM2:  LOAD A0 from D0 */
            `CS_ALU_OP__DEC, `CS_SRCA_A0, `CS_SRCB_A0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC___D0, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM3:  LOAD A0 from D0 */
            `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM4:  Idle*/
            `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM5:  Idle*/
            `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM6:  Idle*/
            `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0,
            `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE,
            `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA,
            `CS_CMP_SEL_CFGA, /*CFGRAM7:  Idle*/
              8'hFF, 8'h00,    /*CFG9:            */
              8'hFF, 8'hFF,    /*CFG11-10: */
            `SC_CMPB_A0_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH,
            `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_ENBL,
            `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI,
            `SC_SI_A_ROUTE, /*CFG13-12:            */
            `SC_A0_SRC_ACC, `SC_SHIFT_SL, 1'h0,
            1'h0, `SC_FIFO1_BUS, `SC_FIFO0_BUS,
            `SC_MSB_DSBL, `SC_MSB_BIT7, `SC_MSB_NOCHN,
            `SC_FB_NOCHN, `SC_CMP1_NOCHN,
            `SC_CMP0_NOCHN, /*CFG15-14:            */
            3'h00, `SC_FIFO_SYNC__ADD, 6'h00,
            `SC_FIFO_CLK__DP,`SC_FIFO_CAP_AX,
            `SC_FIFO__EDGE,`SC_FIFO__SYNC,`SC_EXTCRC_DSBL,
            `SC_WRK16CAT_DSBL /*CFG17-16:            */
        })) ClkGen(
            /* input          */ .reset         (1'b0),
            /* input          */ .clk           (op_clk),
            /* input  [02:00] */ .cs_addr       (cs_addr_clkgen),
            /* input          */ .route_si      (1'b0),
            /* input          */ .route_ci      (1'b0),
            /* input          */ .f0_load       (1'b0),
            /* input          */ .f1_load       (1'b0),
            /* input          */ .d0_load       (1'b0),
            /* input          */ .d1_load       (1'b0),
            /* output         */ .ce0           (),
            /* output         */ .cl0           (),
            /* output         */ .z0            (clkgen_tc),
            /* output         */ .ff0           (),
            /* output         */ .ce1           (clkgen_ce1),
            /* output         */ .cl1           (clkgen_cl1),
            /* output         */ .cl1_reg       (),
            /* output         */ .z1            (),
            /* output         */ .ff1           (),
            /* output         */ .ov_msb        (),
            /* output         */ .co_msb        (),
            /* output         */ .cmsb          (),
            /* output         */ .so            (),
            /* output         */ .f0_bus_stat   (),
            /* output         */ .f0_blk_stat   (),
            /* output         */ .f1_bus_stat   ()
        );
    end /* Master */

    if ((Mode == I2C_MODE_SLAVE)  || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin: Slave
        /***************************************************************************
        * Bit counter.
        * Used for bit counting for address and data shift in and out.
        ****************************************************************************/
        cy_psoc3_count7 #(.cy_period(QUANTITY_OF_BITS), .cy_route_ld(`FALSE), .cy_route_en(`TRUE))
        BitCounter(
            /* input          */ .clock  (op_clk),
            /* input          */ .reset  (s_reset),
            /* input          */ .load   (1'b0),
            /* input          */ .enable (counter_en),
            /* output [06:00] */ .count  ({foo,count}),
            /* output         */ .tc     ()
        );
    end /* Slave */
    endgenerate

    /**************************************************************************
    * Control Register Implementation
    ***************************************************************************/
    generate
    if (CY_UDB_V0)
    begin: SyncedCtlOutput
        /* Sync the Control register outputs to component clock
         * for avoid Setup Time violation on Bus Clock
         */
        always @ (posedge op_clk)
        begin
            control_reg[7:2] <= control [7:2];
        end

        assign ctrl_start_gen   = control_reg [I2C_CTRL_START_GEN];
        assign ctrl_stop_gen    = control_reg [I2C_CTRL_STOP_GEN];
        assign ctrl_restart_gen = control_reg [I2C_CTRL_RESTART_GEN];
        assign ctrl_nack        = control_reg [I2C_CTRL_NACK];
        assign ctrl_hw_addr_en  = control_reg [I2C_CTRL_HW_ADDR_EN];
        assign ctrl_transmit    = control_reg [I2C_CTRL_TRANSMIT];
        assign ctrl_master_en   = control     [I2C_CTRL_MASTER_EN];
        assign ctrl_slave_en    = control     [I2C_CTRL_SLAVE_EN];
    end /* SyncedCtlOutput */

    else
    begin: AsyncCtlOutput
        assign ctrl_start_gen   = control [I2C_CTRL_START_GEN];
        assign ctrl_stop_gen    = control [I2C_CTRL_STOP_GEN];
        assign ctrl_restart_gen = control [I2C_CTRL_RESTART_GEN];
        assign ctrl_nack        = control [I2C_CTRL_NACK];
        assign ctrl_hw_addr_en  = control [I2C_CTRL_HW_ADDR_EN];
        assign ctrl_transmit    = control [I2C_CTRL_TRANSMIT];
        assign ctrl_master_en   = control [I2C_CTRL_MASTER_EN];
        assign ctrl_slave_en    = control [I2C_CTRL_SLAVE_EN];
    end /* AsyncCtlOutput */
    endgenerate

    /**************************************************************************
    * Status Register Implementation
    ***************************************************************************/
    generate
    if (Mode == I2C_MODE_SLAVE)
    begin: SlaveStatus
        assign status [I2C_STS_LOST_ARB]         = 1'b0;
        assign status [I2C_STS_STOP]             = stop_detect;
        assign status [I2C_STS_BUS_BUSY]         = 1'b0;
        assign status [I2C_STS_ADDRESS]          = s_address_reg;
        assign status [I2C_STS_MASTER_MODE]      = 1'b0;
        assign status [I2C_STS_LRB]              = s_lrb_reg;
        assign status [I2C_STS_BYTE_COMPLETE]    = s_byte_complete_reg;
    end /* SlaveStatus */

    else if (Mode == I2C_MODE_MASTER)
    begin: MasterStatus
        assign status [I2C_STS_LOST_ARB]         = 1'b0;
        assign status [I2C_STS_STOP]             = stop_detect;
        assign status [I2C_STS_BUS_BUSY]         = (m_state != I2C_MASTER_IDLE);
        assign status [I2C_STS_ADDRESS]          = m_address_reg;
        assign status [I2C_STS_MASTER_MODE]      = master_mode_reg;
        assign status [I2C_STS_LRB]              = m_lrb_reg;
        assign status [I2C_STS_BYTE_COMPLETE]    = m_byte_complete_reg;
    end /* MasterStatus */

    else if (Mode == I2C_MODE_MULTI_MASTER)
    begin: MultiMasterStatus
        assign status [I2C_STS_LOST_ARB]         = lost_arb_reg;
        assign status [I2C_STS_STOP]             = stop_detect;
        assign status [I2C_STS_BUS_BUSY]         = bus_busy;
        assign status [I2C_STS_ADDRESS]          = m_address_reg;
        assign status [I2C_STS_MASTER_MODE]      = master_mode_reg;
        assign status [I2C_STS_LRB]              = m_lrb_reg;
        assign status [I2C_STS_BYTE_COMPLETE]    = m_byte_complete_reg;
    end /* MultiMasterStatus */

    else if (Mode == I2C_MODE_MULTI_MASTER_SLAVE)
    begin: MultiMasterSlaveStatus
        assign status [I2C_STS_LOST_ARB]         = lost_arb_reg;
        assign status [I2C_STS_STOP]             = stop_detect;
        assign status [I2C_STS_BUS_BUSY]         = bus_busy;
        assign status [I2C_STS_ADDRESS]          = s_address_reg;
        assign status [I2C_STS_MASTER_MODE]      = master_mode_reg;
        assign status [I2C_STS_LRB]              = (m_lrb_reg | s_lrb_reg);
        assign status [I2C_STS_BYTE_COMPLETE]    = (m_byte_complete_reg | s_byte_complete_reg);
    end /* MultiMasterSlaveStatus */
    endgenerate



    /* Save three previous samples of SCL to do start and stop detection.
     * Extra conservative start and stop detction covers the case for zero
     * hold data to clock for both rising and falling SCL (where SDA could
     * fall in sample after SCL change was detected)
     */
    always @(posedge op_clk)
    begin
        scl_in_reg       <= scl_in;
        scl_in_last_reg  <= scl_in_reg;
        scl_in_last2_reg <= scl_in_last_reg;
    end

    /* Save 2 last data values for start/stop detection.
     * Second delayed SDA is used to center the SDA went high/went low
     * around 3 samples of SCL.
     * This insures that the clock was really high when the
     * data changed, to guard against the case when SDA falls
     * in the next sample after SCL due to zero hold of SDA w.r.t. SCL
     */
    always @(posedge op_clk)
    begin
        sda_in_reg       <= sda_in;
        sda_in_last_reg  <= sda_in_reg;
        sda_in_last2_reg <= sda_in_last_reg;
    end

    assign sda_went_low  = !sda_in_last_reg & sda_in_last2_reg;
    assign sda_went_high =  sda_in_last_reg & !sda_in_last2_reg;
    assign scl_went_low  = !scl_in_reg & scl_in_last_reg;
    assign scl_went_high =  scl_in_reg & !scl_in_last_reg;

    /***************************************************************************
    * The Start and Stop detect.
    ****************************************************************************
    * SDA went low/high in the middle sample of 3 high SCLs
    * For Slave the Start detect resets all state in the block, this excepted.
    ****************************************************************************/
    assign start_detect = sda_went_low  & scl_in_reg & scl_in_last_reg & scl_in_last2_reg;
    assign stop_detect  = sda_went_high & scl_in_reg & scl_in_last_reg & scl_in_last2_reg;

    generate
    if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /***************************************************************************
        * Master and MultiMaster Protocol State Machine.
        ****************************************************************************
        * Includes states and byte complete computation.
        * State changes are aligned with input shifting which is on the positive
        * edge of SCL.
        * There are two flows: RX data/address, and TX data, and the address
        * state bit distinguishes between RX data and address.
        ****************************************************************************/
        always @(posedge op_clk)
        begin
            if (m_reset) m_state <= I2C_MASTER_IDLE;
            else if (clkgen_tc1_reg)
                begin
                    case (m_state)

                        I2C_MASTER_IDLE:
                        begin
                            /* Waiting for bus free only in Multi-Mmaster mode.
                             * The transaction is queued.
                             */
                            if (bus_busy)           m_state <= I2C_MASTER_IDLE;
                            else if (~tx_reg_empty) m_state <= I2C_MASTER_PRE_START;
                        end

                        I2C_MASTER_PRE_START:
                        begin
                            /* Waiting for bus free in Multi-Mmaster modes. */
                            if (bus_busy)           m_state <= I2C_MASTER_WAIT;
                            else                    m_state <= I2C_MASTER_START;
                        end

                        /* Need this state to ensure tBUF interval */
                        I2C_MASTER_WAIT:
                        begin
                            if (~ctrl_start_gen)    m_state <= I2C_MASTER_IDLE;
                            else if (bus_busy)      m_state <= I2C_MASTER_WAIT;
                            else                    m_state <= I2C_MASTER_PRE_START;
                        end

                        I2C_MASTER_START:   m_state <= I2C_MASTER_TX_D0;
                        I2C_MASTER_TX_D0:   m_state <= I2C_MASTER_TX_D1;
                        I2C_MASTER_TX_D1:   m_state <= I2C_MASTER_TX_D2;
                        I2C_MASTER_TX_D2:   m_state <= I2C_MASTER_TX_D3;
                        I2C_MASTER_TX_D3:   m_state <= I2C_MASTER_TX_D4;
                        I2C_MASTER_TX_D4:   m_state <= I2C_MASTER_TX_D5;
                        I2C_MASTER_TX_D5:   m_state <= I2C_MASTER_TX_D6;
                        I2C_MASTER_TX_D6:   m_state <= I2C_MASTER_TX_D7;

                        I2C_MASTER_TX_D7:
                        begin
                            if (Mode == I2C_MODE_MULTI_MASTER_SLAVE &&
                                (lost_arb_reg  &
                                 s_address_reg   &
                                 address_match &
                                 ~ctrl_hw_addr_en)) m_state <= I2C_MASTER_IDLE;
                            else                    m_state <= I2C_MASTER_TX_ACK;
                        end

                        I2C_MASTER_TX_ACK:  m_state <= I2C_MASTER_TX_STALL;

                        /* This could be on address ACK or data ACK */
                        I2C_MASTER_TX_STALL:
                        begin
                            if (~tx_reg_empty)
                            begin
                                if (lost_arb_reg)           m_state <= I2C_MASTER_IDLE;
                                else if (ctrl_stop_gen)     m_state <= I2C_MASTER_STOP;
                                else if (ctrl_restart_gen)  m_state <= I2C_MASTER_RESTART;
                                else if (ctrl_transmit)     m_state <= I2C_MASTER_TX_D0;
                                else                        m_state <= I2C_MASTER_RX_D0;
                            end
                            else                            m_state <= I2C_MASTER_TX_STALL;
                        end

                        I2C_MASTER_RX_D0:   m_state <= I2C_MASTER_RX_D1;
                        I2C_MASTER_RX_D1:   m_state <= I2C_MASTER_RX_D2;
                        I2C_MASTER_RX_D2:   m_state <= I2C_MASTER_RX_D3;
                        I2C_MASTER_RX_D3:   m_state <= I2C_MASTER_RX_D4;
                        I2C_MASTER_RX_D4:   m_state <= I2C_MASTER_RX_D5;
                        I2C_MASTER_RX_D5:   m_state <= I2C_MASTER_RX_D6;
                        I2C_MASTER_RX_D6:   m_state <= I2C_MASTER_RX_D7;
                        I2C_MASTER_RX_D7:   m_state <= I2C_MASTER_RX_STALL;

                        I2C_MASTER_RX_STALL:
                        begin
                            if (~tx_reg_empty)
                              begin
                                  if (lost_arb_reg) m_state <= I2C_MASTER_IDLE;
                                  else              m_state <= I2C_MASTER_RX_ACK;
                              end
                            else                    m_state <= I2C_MASTER_RX_STALL;
                        end

                        I2C_MASTER_RX_ACK:
                        begin
                            if (ctrl_nack & ~lost_arb2_reg)
                            begin
                                if (ctrl_restart_gen)   m_state <= I2C_MASTER_RESTART;
                                else                    m_state <= I2C_MASTER_STOP;
                            end
                            else                        m_state <= I2C_MASTER_RX_D0;

                        end

                        /* Need this state to setup the start SDA goes high from whereever it was */
                        I2C_MASTER_RESTART: m_state <= I2C_MASTER_START;

                        /* Generate STOP hold time */
                        I2C_MASTER_STOP:    m_state <= I2C_MASTER_IDLE;

                        default:            m_state <= I2C_MASTER_IDLE;
                  endcase
              end
        end

        /* Need to manually register TC until we can have both registered and combo version out */
        always @(posedge op_clk)
        begin
            if (m_reset) clkgen_tc1_reg <= 1'b1;
            else         clkgen_tc1_reg <= (clkgen_tc | cnt_reset);
        end

        /* Delayed so data can be changed one cycle after clock for hold */
        always @(posedge op_clk)
        begin
            if (m_reset) clkgen_tc2_reg <= 1'b1;
            else         clkgen_tc2_reg <= clkgen_tc1_reg;
        end

        /***************************************************************************
        * Byte complete.
        ****************************************************************************
        * Need it to match the Fixed Function implementation.
        * So instead of a pulse that is capture by sticky register we have a
        * sticky register in PLD that is cleared by GO
        ****************************************************************************/
        always @(posedge op_clk)
        begin
            if (m_reset)                                m_byte_complete_reg <= 1'b0;
            else if (m_load_dummy)                      m_byte_complete_reg <= 1'b0;
            else if (m_state == I2C_MASTER_TX_STALL ||
                     m_state == I2C_MASTER_RX_STALL)    m_byte_complete_reg <= 1'b1;
        end

        /* This bit is set/cleared when the device is operating as a master.
         * '0' stop condition detected, generated by this device.
         * '1' start condition detected, generated by this device.
         */
        always @(posedge op_clk)
        begin
            if (m_reset)                            master_mode_reg <= 1'b0;
            else if (m_state == I2C_MASTER_IDLE)    master_mode_reg <= 1'b0;
            else if (m_state == I2C_MASTER_STOP)    master_mode_reg <= 1'b0;
            else if (m_state == I2C_MASTER_START)   master_mode_reg <= 1'b1;
        end

        /* LRB (last received bit, which is ACK/NACK from the slave on WRITE command */
        always @(posedge op_clk)
        begin
            if (m_reset)                                                m_lrb_reg <= 1'b0;
            else if (clkgen_tc1_reg && m_state == I2C_MASTER_TX_ACK)    m_lrb_reg <= sda_in;
        end

        /* Contention (Multi-Master only)
         * Optimized out for simple Master
         * Check for contention at the sample points, when the master is transmitting
         */
        assign contention = (clkgen_tc | cnt_reset) & (txdata | m_state == I2C_MASTER_RX_ACK) & (sda_out != sda_in_reg);

        /* Do positive edge detect on contention goes
         * to FSM (to IDLE), and sticky status register
         */
        always @(posedge op_clk)
        begin
            if (m_reset) contention1_reg <= 1'b0;
            else         contention1_reg <= contention;
        end

        assign lost_arb = (Mode == I2C_MODE_MASTER) ? 1'b0 : (contention & ~contention1_reg);

        always @(posedge op_clk)
        begin
            if (m_reset)                                                            lost_arb_reg <= 1'b0;
            else if (m_load_dummy |
                    ((Mode == I2C_MODE_MULTI_MASTER_SLAVE) ? s_load_dummy : 1'b0))  lost_arb_reg <= 1'b0;
            else if (lost_arb)                                                      lost_arb_reg <= 1'b1;
        end

        always @(posedge op_clk)
        begin
            if (m_reset) lost_arb2_reg <= 1'b0;
            else         lost_arb2_reg <= lost_arb;
        end

        /***************************************************************************
        * Bus busy computation.
        ****************************************************************************
        * Simple decode of IDLE for single Master, use Start and Stop detect for
        * MultiMmaster mode.
        ****************************************************************************/
        assign bus_busy = (Mode == I2C_MODE_MASTER) ? 1'b0 : bus_busy_reg;

        always @(posedge op_clk)
        begin
            if (m_reset) bus_busy_reg <= 1'b0;
            else         bus_busy_reg <= (start_detect | bus_busy_reg) & ~stop_detect;
        end

        /* State decodes for convenience */
        assign rxdata = m_state == I2C_MASTER_RX_D0 |
                        m_state == I2C_MASTER_RX_D1 |
                        m_state == I2C_MASTER_RX_D2 |
                        m_state == I2C_MASTER_RX_D3 |
                        m_state == I2C_MASTER_RX_D4 |
                        m_state == I2C_MASTER_RX_D5 |
                        m_state == I2C_MASTER_RX_D6 |
                        m_state == I2C_MASTER_RX_D7;

        assign txdata = m_state == I2C_MASTER_TX_D0 |
                        m_state == I2C_MASTER_TX_D1 |
                        m_state == I2C_MASTER_TX_D2 |
                        m_state == I2C_MASTER_TX_D3 |
                        m_state == I2C_MASTER_TX_D4 |
                        m_state == I2C_MASTER_TX_D5 |
                        m_state == I2C_MASTER_TX_D6 |
                        m_state == I2C_MASTER_TX_D7;

        assign stalled = (m_state == I2C_MASTER_TX_STALL | m_state == I2C_MASTER_RX_STALL);

        always @(posedge op_clk)
        begin
            if (m_reset)                          m_address_reg <= 1'b0;
            else if (m_load_dummy)                m_address_reg <= 1'b0;
            else if (m_state == I2C_MASTER_IDLE)  m_address_reg <= 1'b0;
            else if (m_state == I2C_MASTER_START) m_address_reg <= 1'b1;
        end

        /***************************************************************************
        * I2C clock synchronisation logic.
        ****************************************************************************
        * The synchronized SCL clock is generated with its LOW period determined by
        * the device with the longest clock LOW period, and its HIGH period determined
        * by the one with the shortest clock HIGH period.
        ****************************************************************************/
        always @(posedge op_clk)
        begin
            clk_eq_reg <= (scl_out == scl_in);
        end

        assign cnt_reset =  (scl_out & scl_went_low) &
                             ~clkgen_tc1_reg &
                            (m_state != I2C_MASTER_IDLE) &
                            (m_state != I2C_MASTER_PRE_START) &
                            (m_state != I2C_MASTER_WAIT);

        assign clkgen_en = ((m_state == I2C_MASTER_IDLE & ~tx_reg_empty) | (m_state != I2C_MASTER_IDLE)) & clk_eq_reg;

        assign cs_addr_clkgen = {1'b0, (clkgen_tc | cnt_reset), clkgen_en};

        /* Compute when to continue transfer, CPU signals this with a write to FIFO F1.
         * This is dummy data, it isn't used, its loaded into A1.
         * Check (m_state != I2C_MASTER_IDLE) because the transaction must be queued.
         */
        assign m_load_dummy = (~tx_reg_empty & clkgen_tc1_reg) & (m_state != I2C_MASTER_IDLE);

        /* Compute when to enable shifting */
        assign m_shift_en = (clkgen_tc | cnt_reset) & (rxdata | txdata);
    end

    if ((Mode == I2C_MODE_SLAVE) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /**************************************************************************
        * Slave Protocol State Machine.
        **************************************************************************/
        always @(posedge op_clk)
        begin
            if (s_reset)
            begin
                s_state <= I2C_SLAVE_IDLE;
                s_byte_complete_reg <= 1'b0;
            end
            else
            begin
                if (s_load_dummy) s_byte_complete_reg <= 1'b0;

                case (s_state)

                    /* Stay in IDLE state until Start condition is detected */
                    I2C_SLAVE_IDLE:
                    begin
                        if (start_sample_reg) s_state <= I2C_SLAVE_RX_DATA;
                        else                  s_state <= I2C_SLAVE_IDLE;
                    end

                    /* WRITE (address or data)
                     * The address state bit is used to distinguish
                     * If an address and a match (or any address), stall, otherwise idle
                     */
                    I2C_SLAVE_RX_DATA:
                    begin
                        if (scl_went_high && counter_eq_zero)
                        begin
                            if (!s_address_reg | (s_address_reg & (address_match | ctrl_hw_addr_en)))
                            begin
                                s_byte_complete_reg <= 1'b1;
                                s_state <= I2C_SLAVE_RX_STALL;
                            end
                            else s_state <= I2C_SLAVE_IDLE;
                        end
                        else s_state <= I2C_SLAVE_RX_DATA;
                    end

                    /* Local CPU is reading address and deciding what to do, tx or rx, etc
                     * Wait for a dummy write to the tx registe to start either read or write
                     * If a write, local CPU can NACK... better not do this on address state
                     */
                    I2C_SLAVE_RX_STALL:
                    begin
                        if (scl_in_reg == 1'b0 & ~tx_reg_empty)
                        begin
                            /* foo - go to ACK then idle? to be compatible with master
                             * would need to also change sda_out computation if this changes (ctrl_nack)
                             */
                            if (ctrl_nack)  s_state <= I2C_SLAVE_IDLE;
                            else            s_state <= I2C_SLAVE_RX_ACK;
                        end
                        else                s_state <= I2C_SLAVE_RX_STALL;
                    end

                    /* ACK the received address or data */
                    I2C_SLAVE_RX_ACK:
                    begin
                        if (scl_went_high)
                        begin
                            if (ctrl_transmit)  s_state <= I2C_SLAVE_TX_DATA;
                            else                s_state <= I2C_SLAVE_RX_DATA;
                        end
                        else                    s_state <= I2C_SLAVE_RX_ACK;
                    end

                    /* READ 8-bits of data is shifting out */
                    I2C_SLAVE_TX_DATA:
                    begin
                        if (scl_went_high & counter_eq_zero) s_state <= I2C_SLAVE_TX_ACK;
                        else                               s_state <= I2C_SLAVE_TX_DATA;
                    end

                    /* Check for the ACK from the external master
                     * If it's a NACK, then idle
                     */
                    I2C_SLAVE_TX_ACK:
                    begin
                        if (scl_went_high)
                        begin
                            s_byte_complete_reg <= 1'b1;
                            s_state <= I2C_SLAVE_TX_STALL;
                        end
                    end

                    /* External master ACKed, so it wants more bytes */
                    I2C_SLAVE_TX_STALL:
                    begin
                        if (scl_in_reg == 1'b0  & ~tx_reg_empty)  s_state <= I2C_SLAVE_TX_DATA;
                        else                                      s_state <= I2C_SLAVE_TX_STALL;
                    end

                    default: s_state <= I2C_SLAVE_IDLE;
              endcase
            end
        end

        /* LRB (last received bit, which is ACK/NACK from the master on WRITE command */
        always @(posedge op_clk)
        begin
            if (s_reset)                                           s_lrb_reg <= 1'b0;
            else if (scl_went_high & s_state == I2C_SLAVE_TX_ACK ) s_lrb_reg <= sda_in_reg;
        end

        always @(posedge op_clk)
        begin
            start_sample0_reg <= start_detect;
            start_sample_reg <= start_sample0_reg;
        end

        /* Address bit distinguish the address reception from data reception
         * This is sticky until the user writes to continue the transfer
         */
        always @(posedge op_clk)
        begin
            if (s_reset) s_address_reg <= 1'b0;
            else         s_address_reg <= (start_sample_reg | s_address_reg) & tx_reg_empty |
                         ( ~tx_reg_empty & (s_state == I2C_SLAVE_RX_DATA | s_state == I2C_SLAVE_TX_DATA));
        end

        /* Compute when to count */
        assign counter_en = start_sample_reg | s_shift_en;

        assign counter_eq_zero = (count == 3'b0);

        assign s_load_dummy = (scl_in_reg == 1'b0) & ~tx_reg_empty &
                              (s_state == I2C_SLAVE_RX_STALL | s_state == I2C_SLAVE_TX_STALL);

        assign s_shift_en = scl_went_high & (s_state == I2C_SLAVE_RX_DATA | s_state == I2C_SLAVE_TX_DATA);
    end
    endgenerate

    /*************************************************************************
    * Bit Controller.
    **************************************************************************/
    generate
    if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /* Master SCL out */
        always @(posedge op_clk)
        begin
            if (m_reset)                                             m_scl_out_reg <= 1'b1;
            else if (stalled | cnt_reset )                           m_scl_out_reg <= 1'b0;
            else if (m_state == I2C_MASTER_RESTART & clkgen_tc1_reg) m_scl_out_reg <= 1'b1;
            else if (m_state == I2C_MASTER_START & clkgen_tc1_reg)   m_scl_out_reg <= clkgen_cl1;
            else if (m_state == I2C_MASTER_STOP & clkgen_tc1_reg)    m_scl_out_reg <= 1'b1;
            else if ((m_state != I2C_MASTER_IDLE) &&
                     (m_state != I2C_MASTER_START) &&
                     (m_state != I2C_MASTER_PRE_START) &&
                     (m_state != I2C_MASTER_WAIT))                   m_scl_out_reg <= clkgen_cl1;
            else                                                     m_scl_out_reg <= 1'b1;
        end

        /* Master SDA out */
        always @(posedge op_clk)
        begin
            if (m_reset)                                    m_sda_out_reg <= 1'b1;
            else if (clkgen_tc2_reg)
                begin
                    if ((m_state == I2C_MASTER_START) ||
                        (m_state == I2C_MASTER_STOP) ||
                        (m_state == I2C_MASTER_RX_ACK &
                         ~ctrl_nack & ~lost_arb_reg))       m_sda_out_reg <= 1'b0;
                    else if (txdata & ~lost_arb_reg)        m_sda_out_reg <= shift_data_out;
                    else                                    m_sda_out_reg <= 1'b1;
                end
        end
    end

    if ((Mode == I2C_MODE_SLAVE)  || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /* Compute SCL_OUT for stalling
         * once scl_out goes low it's "latched" because the master stops
         * released when we change state because of a FIFO write
         */
        always @(posedge op_clk)
        begin
            if (s_reset)                                                    s_scl_out_reg <= 1'b1;
            else if (s_state == I2C_SLAVE_RX_STALL && scl_in_reg == 1'b0)   s_scl_out_reg <= 1'b0;
            else if (s_state == I2C_SLAVE_TX_STALL && scl_in_reg == 1'b0)   s_scl_out_reg <= 1'b0;
            else                                                            s_scl_out_reg <= 1'b1;
        end

        /* Compute SDA out change only on the negative edge of SCL */
        always @(posedge op_clk)
        begin
            if (s_reset)                                      s_sda_out_reg <= 1'b1;
            /* Output data only on the negative edge or if the clock is low */
            else if (scl_went_low || scl_out == 1'b0)
                begin
                    if (s_state == I2C_SLAVE_TX_STALL ||
                        s_state == I2C_SLAVE_TX_DATA)         s_sda_out_reg <= shift_data_out;
                    else if (s_state == I2C_SLAVE_RX_ACK)     s_sda_out_reg <= 1'b0;
                    else                                      s_sda_out_reg <= 1'b1;
                end
        end
    end
    endgenerate


    /*************************************************************************
    * The datapath cs_addr selection
    **************************************************************************/
    generate
    if (Mode == I2C_MODE_SLAVE)
    begin
        assign sda_out = s_sda_out_reg;
        assign scl_out = s_scl_out_reg;
        assign cs_addr_shifter = {1'b0, s_load_dummy, s_shift_en};
    end

    else if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER))
    begin
        assign sda_out = m_sda_out_reg;
        assign scl_out = m_scl_out_reg;
        assign cs_addr_shifter = {1'b0, m_load_dummy , m_shift_en};
    end

    else if (Mode == I2C_MODE_MULTI_MASTER_SLAVE)
    begin
        assign sda_out = m_sda_out_reg & s_sda_out_reg;
        assign scl_out = m_scl_out_reg & s_scl_out_reg;
        assign cs_addr_shifter = {1'b0, (m_load_dummy | s_load_dummy), (m_shift_en | (s_shift_en & ~master_mode_reg))};
    end
    endgenerate

    /**************************************************************************
    * Interrupt logic
    ***************************************************************************/
    generate
    if (Mode == I2C_MODE_MULTI_MASTER_SLAVE)
    begin
        always @(posedge op_clk)
        begin
            if (s_reset) irq_reg <= 1'b0;
            else         irq_reg <= sts_irq;
        end

        /* If Hardware Address Match is ENABLED the interrupt ONLY generates when
         * arbitrage take place on address phase and received address is Slave address.
         * If Hardware Address Match is DISABLED the interrupt generates on all types
         * of arbitrage conditions (The same behavior as Fixed Function implementation has).
         */
        assign irq_final = (lost_arb_reg & s_address_reg &
                            ~address_match & ~ctrl_hw_addr_en) ? 1'b0 : (sts_irq & ~irq_reg);
    end
    endgenerate

    assign interrupt = (Mode == I2C_MODE_MULTI_MASTER_SLAVE) ? irq_final : sts_irq;

    /**************************************************************************
    * Reset logic
    ***************************************************************************/

    /* The start detect resets all state in the block, this excepted */
    always @(posedge op_clk)
    begin
        slave_rst_reg <= reset | start_detect | ~ctrl_slave_en;
    end

    always @(posedge op_clk)
    begin
        master_rst_reg <= reset | ~ctrl_master_en;
    end

    generate
    if ((Mode == I2C_MODE_MASTER) || (Mode == I2C_MODE_MULTI_MASTER) || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /* Master reset signal*/
        assign m_reset = master_rst_reg;
    end

    if ((Mode == I2C_MODE_SLAVE)  || (Mode == I2C_MODE_MULTI_MASTER_SLAVE))
    begin
        /* Slave reset signal*/
        assign s_reset = slave_rst_reg;
    end
    endgenerate

endmodule /* bI2C_v3_20 */
`endif /* bI2C_v3_20_V_ALREADY_INCLUDED */


